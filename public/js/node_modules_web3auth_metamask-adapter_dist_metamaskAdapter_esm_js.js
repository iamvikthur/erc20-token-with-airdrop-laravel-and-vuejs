"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_web3auth_metamask-adapter_dist_metamaskAdapter_esm_js"],{

/***/ "./node_modules/@metamask/detect-provider/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@metamask/detect-provider/dist/index.js ***!
  \**************************************************************/
/***/ ((module) => {


/**
 * Returns a Promise that resolves to the value of window.ethereum if it is
 * set within the given timeout, or null.
 * The Promise will not reject, but an error will be thrown if invalid options
 * are provided.
 *
 * @param options - Options bag.
 * @param options.mustBeMetaMask - Whether to only look for MetaMask providers.
 * Default: false
 * @param options.silent - Whether to silence console errors. Does not affect
 * thrown errors. Default: false
 * @param options.timeout - Milliseconds to wait for 'ethereum#initialized' to
 * be dispatched. Default: 3000
 * @returns A Promise that resolves with the Provider if it is detected within
 * given timeout, otherwise null.
 */
function detectEthereumProvider({ mustBeMetaMask = false, silent = false, timeout = 3000, } = {}) {
    _validateInputs();
    let handled = false;
    return new Promise((resolve) => {
        if (window.ethereum) {
            handleEthereum();
        }
        else {
            window.addEventListener('ethereum#initialized', handleEthereum, { once: true });
            setTimeout(() => {
                handleEthereum();
            }, timeout);
        }
        function handleEthereum() {
            if (handled) {
                return;
            }
            handled = true;
            window.removeEventListener('ethereum#initialized', handleEthereum);
            const { ethereum } = window;
            if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {
                resolve(ethereum);
            }
            else {
                const message = mustBeMetaMask && ethereum
                    ? 'Non-MetaMask window.ethereum detected.'
                    : 'Unable to detect window.ethereum.';
                !silent && console.error('@metamask/detect-provider:', message);
                resolve(null);
            }
        }
    });
    function _validateInputs() {
        if (typeof mustBeMetaMask !== 'boolean') {
            throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);
        }
        if (typeof silent !== 'boolean') {
            throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);
        }
        if (typeof timeout !== 'number') {
            throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);
        }
    }
}
module.exports = detectEthereumProvider;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQVlBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILFNBQVMsc0JBQXNCLENBQUMsRUFDOUIsY0FBYyxHQUFHLEtBQUssRUFDdEIsTUFBTSxHQUFHLEtBQUssRUFDZCxPQUFPLEdBQUcsSUFBSSxHQUNmLEdBQUcsRUFBRTtJQUVKLGVBQWUsRUFBRSxDQUFDO0lBRWxCLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztJQUVwQixPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDN0IsSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFO1lBRW5CLGNBQWMsRUFBRSxDQUFDO1NBRWxCO2FBQU07WUFFTCxNQUFNLENBQUMsZ0JBQWdCLENBQ3JCLHNCQUFzQixFQUN0QixjQUFjLEVBQ2QsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQ2YsQ0FBQztZQUVGLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2QsY0FBYyxFQUFFLENBQUM7WUFDbkIsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2I7UUFFRCxTQUFTLGNBQWM7WUFFckIsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsT0FBTzthQUNSO1lBQ0QsT0FBTyxHQUFHLElBQUksQ0FBQztZQUVmLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxzQkFBc0IsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUVuRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsTUFBTSxDQUFDO1lBRTVCLElBQUksUUFBUSxJQUFJLENBQUMsQ0FBQyxjQUFjLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUN4RCxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDbkI7aUJBQU07Z0JBRUwsTUFBTSxPQUFPLEdBQUcsY0FBYyxJQUFJLFFBQVE7b0JBQ3hDLENBQUMsQ0FBQyx3Q0FBd0M7b0JBQzFDLENBQUMsQ0FBQyxtQ0FBbUMsQ0FBQztnQkFFeEMsQ0FBQyxNQUFNLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDaEUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2Y7UUFDSCxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxTQUFTLGVBQWU7UUFDdEIsSUFBSSxPQUFPLGNBQWMsS0FBSyxTQUFTLEVBQUU7WUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyw4RUFBOEUsQ0FBQyxDQUFDO1NBQ2pHO1FBQ0QsSUFBSSxPQUFPLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxzRUFBc0UsQ0FBQyxDQUFDO1NBQ3pGO1FBQ0QsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7WUFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxzRUFBc0UsQ0FBQyxDQUFDO1NBQ3pGO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFsRkQsaUJBQVMsc0JBQXNCLENBQUMifQ==

/***/ }),

/***/ "./node_modules/@web3auth/metamask-adapter/dist/metamaskAdapter.esm.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@web3auth/metamask-adapter/dist/metamaskAdapter.esm.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MetamaskAdapter": () => (/* binding */ MetamaskAdapter)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _metamask_detect_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @metamask/detect-provider */ "./node_modules/@metamask/detect-provider/dist/index.js");
/* harmony import */ var _metamask_detect_provider__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_metamask_detect_provider__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _web3auth_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @web3auth/base */ "./node_modules/@web3auth/base/dist/base.esm.js");




class MetamaskAdapter extends _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.BaseAdapter {
  constructor() {
    let adapterOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super();

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "adapterNamespace", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_NAMESPACES.EIP155);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "currentChainNamespace", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.CHAIN_NAMESPACES.EIP155);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "type", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_CATEGORY.EXTERNAL);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "name", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WALLET_ADAPTERS.METAMASK);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "status", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.NOT_READY);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "rehydrated", false);

    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "metamaskProvider", null);

    this.chainConfig = adapterOptions.chainConfig || null;
  }

  get provider() {
    if (this.status === _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTED && this.metamaskProvider) {
      return this.metamaskProvider;
    }

    return null;
  }

  set provider(_) {
    throw new Error("Not implemented");
  }

  async init(options) {
    super.checkInitializationRequirements();
    this.metamaskProvider = await _metamask_detect_provider__WEBPACK_IMPORTED_MODULE_1___default()({
      mustBeMetaMask: true
    });
    if (!this.metamaskProvider) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletInitializationError.notInstalled("Metamask extension is not installed");
    this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.READY;
    this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.READY, _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WALLET_ADAPTERS.METAMASK);

    try {
      _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.log.debug("initializing metamask adapter");

      if (options.autoConnect) {
        this.rehydrated = true;
        await this.connect();
      }
    } catch (error) {
      this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.ERRORED, error);
    }
  }

  setAdapterSettings(_) {}

  async connect() {
    super.checkConnectionRequirements(); // set default to mainnet

    if (!this.chainConfig) this.chainConfig = (0,_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.getChainConfig)(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.CHAIN_NAMESPACES.EIP155, 1);
    this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTING;
    this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.CONNECTING, {
      adapter: _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WALLET_ADAPTERS.METAMASK
    });
    if (!this.metamaskProvider) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletLoginError.notConnectedError("Not able to connect with metamask");

    try {
      await this.metamaskProvider.request({
        method: "eth_requestAccounts"
      });
      const {
        chainId
      } = this.metamaskProvider;

      if (chainId !== this.chainConfig.chainId) {
        await this.switchChain(this.chainConfig);
      }

      this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTED;
      if (!this.provider) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletLoginError.notConnectedError("Failed to connect with provider");
      this.provider.once("disconnect", () => {
        // ready to be connected again
        this.disconnect();
      });
      this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.CONNECTED, {
        adapter: _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WALLET_ADAPTERS.METAMASK,
        reconnected: this.rehydrated
      });
      return this.provider;
    } catch (error) {
      // ready again to be connected
      this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.READY;
      this.rehydrated = false;
      this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.ERRORED, error);
      throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletLoginError.connectionError("Failed to login with metamask wallet");
    }
  }

  async disconnect() {
    var _this$provider;

    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      cleanup: false
    };
    if (this.status !== _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTED) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletLoginError.disconnectionError("Not connected with wallet");
    (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.removeAllListeners();

    if (options.cleanup) {
      this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.NOT_READY;
      this.metamaskProvider = null;
    } else {
      // ready to be connected again
      this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.READY;
    }

    this.rehydrated = false;
    this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.DISCONNECTED);
  }

  async getUserInfo() {
    if (this.status !== _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTED) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
    return {};
  }

  async switchChain(chainConfig) {
    if (!this.metamaskProvider) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletLoginError.notConnectedError("Not connected with wallet");

    try {
      await this.metamaskProvider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: chainConfig.chainId
        }]
      });
    } catch (switchError) {
      // This error code indicates that the chain has not been added to MetaMask.
      if (switchError.code === 4902) {
        await this.metamaskProvider.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: chainConfig.chainId,
            chainName: chainConfig.displayName,
            rpcUrls: [chainConfig.rpcTarget]
          }]
        });
      } else {
        throw switchError;
      }
    }
  }

}


//# sourceMappingURL=metamaskAdapter.esm.js.map


/***/ })

}]);